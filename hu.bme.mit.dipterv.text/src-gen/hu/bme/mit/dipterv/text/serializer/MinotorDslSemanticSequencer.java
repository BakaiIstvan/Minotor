/*
 * generated by Xtext 2.24.0
 */
package hu.bme.mit.dipterv.text.serializer;

import com.google.inject.Inject;
import hu.bme.mit.dipterv.text.minotorDsl.Alt;
import hu.bme.mit.dipterv.text.minotorDsl.AndExpression;
import hu.bme.mit.dipterv.text.minotorDsl.AppearMessage;
import hu.bme.mit.dipterv.text.minotorDsl.AssertionEntity;
import hu.bme.mit.dipterv.text.minotorDsl.AssertionRelation;
import hu.bme.mit.dipterv.text.minotorDsl.Attribute;
import hu.bme.mit.dipterv.text.minotorDsl.AttributeValue;
import hu.bme.mit.dipterv.text.minotorDsl.ChangeMessage;
import hu.bme.mit.dipterv.text.minotorDsl.ChangeToMessage;
import hu.bme.mit.dipterv.text.minotorDsl.ChangeToRelation;
import hu.bme.mit.dipterv.text.minotorDsl.Clock;
import hu.bme.mit.dipterv.text.minotorDsl.ClockConstraint;
import hu.bme.mit.dipterv.text.minotorDsl.ClockConstraintExpression;
import hu.bme.mit.dipterv.text.minotorDsl.ConstantParams;
import hu.bme.mit.dipterv.text.minotorDsl.Constraint;
import hu.bme.mit.dipterv.text.minotorDsl.ContextFragment;
import hu.bme.mit.dipterv.text.minotorDsl.ContextMessage;
import hu.bme.mit.dipterv.text.minotorDsl.ContextMessageContent;
import hu.bme.mit.dipterv.text.minotorDsl.ContextModel;
import hu.bme.mit.dipterv.text.minotorDsl.DisappearMessage;
import hu.bme.mit.dipterv.text.minotorDsl.Domain;
import hu.bme.mit.dipterv.text.minotorDsl.Entity;
import hu.bme.mit.dipterv.text.minotorDsl.EqualsBooleanExpression;
import hu.bme.mit.dipterv.text.minotorDsl.EqualsExpression;
import hu.bme.mit.dipterv.text.minotorDsl.Expression;
import hu.bme.mit.dipterv.text.minotorDsl.FEntity;
import hu.bme.mit.dipterv.text.minotorDsl.FRelation;
import hu.bme.mit.dipterv.text.minotorDsl.FragmentAttribute;
import hu.bme.mit.dipterv.text.minotorDsl.GreaterThanExpression;
import hu.bme.mit.dipterv.text.minotorDsl.Include;
import hu.bme.mit.dipterv.text.minotorDsl.LesserThanExpression;
import hu.bme.mit.dipterv.text.minotorDsl.Loop;
import hu.bme.mit.dipterv.text.minotorDsl.MatchMessage;
import hu.bme.mit.dipterv.text.minotorDsl.Message;
import hu.bme.mit.dipterv.text.minotorDsl.MinotorDslPackage;
import hu.bme.mit.dipterv.text.minotorDsl.NotLogicalExpression;
import hu.bme.mit.dipterv.text.minotorDsl.ObjectType;
import hu.bme.mit.dipterv.text.minotorDsl.Operator;
import hu.bme.mit.dipterv.text.minotorDsl.OrExpression;
import hu.bme.mit.dipterv.text.minotorDsl.Par;
import hu.bme.mit.dipterv.text.minotorDsl.ParExpression;
import hu.bme.mit.dipterv.text.minotorDsl.ParameterConstraint;
import hu.bme.mit.dipterv.text.minotorDsl.Params;
import hu.bme.mit.dipterv.text.minotorDsl.Relation;
import hu.bme.mit.dipterv.text.minotorDsl.ResetClock;
import hu.bme.mit.dipterv.text.minotorDsl.Scenario;
import hu.bme.mit.dipterv.text.minotorDsl.ScenarioContent;
import hu.bme.mit.dipterv.text.services.MinotorDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MinotorDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MinotorDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MinotorDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MinotorDslPackage.ALT:
				sequence_Alt(context, (Alt) semanticObject); 
				return; 
			case MinotorDslPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case MinotorDslPackage.APPEAR_MESSAGE:
				sequence_AppearMessage(context, (AppearMessage) semanticObject); 
				return; 
			case MinotorDslPackage.ASSERTION_ENTITY:
				sequence_AssertionEntity(context, (AssertionEntity) semanticObject); 
				return; 
			case MinotorDslPackage.ASSERTION_RELATION:
				sequence_AssertionRelation(context, (AssertionRelation) semanticObject); 
				return; 
			case MinotorDslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case MinotorDslPackage.ATTRIBUTE_VALUE:
				sequence_AttributeValue(context, (AttributeValue) semanticObject); 
				return; 
			case MinotorDslPackage.CHANGE_MESSAGE:
				sequence_ChangeMessage(context, (ChangeMessage) semanticObject); 
				return; 
			case MinotorDslPackage.CHANGE_TO_MESSAGE:
				sequence_ChangeToMessage(context, (ChangeToMessage) semanticObject); 
				return; 
			case MinotorDslPackage.CHANGE_TO_RELATION:
				sequence_ChangeToRelation(context, (ChangeToRelation) semanticObject); 
				return; 
			case MinotorDslPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case MinotorDslPackage.CLOCK_CONSTRAINT:
				sequence_ClockConstraint(context, (ClockConstraint) semanticObject); 
				return; 
			case MinotorDslPackage.CLOCK_CONSTRAINT_EXPRESSION:
				sequence_ClockConstraintExpression(context, (ClockConstraintExpression) semanticObject); 
				return; 
			case MinotorDslPackage.CONSTANT_PARAMS:
				sequence_ConstantParams(context, (ConstantParams) semanticObject); 
				return; 
			case MinotorDslPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case MinotorDslPackage.CONTEXT_FRAGMENT:
				sequence_ContextFragment(context, (ContextFragment) semanticObject); 
				return; 
			case MinotorDslPackage.CONTEXT_MESSAGE:
				sequence_ContextMessage(context, (ContextMessage) semanticObject); 
				return; 
			case MinotorDslPackage.CONTEXT_MESSAGE_CONTENT:
				sequence_ContextMessageContent(context, (ContextMessageContent) semanticObject); 
				return; 
			case MinotorDslPackage.CONTEXT_MODEL:
				sequence_ContextModel(context, (ContextModel) semanticObject); 
				return; 
			case MinotorDslPackage.DISAPPEAR_MESSAGE:
				sequence_DisappearMessage(context, (DisappearMessage) semanticObject); 
				return; 
			case MinotorDslPackage.DOMAIN:
				sequence_Domain(context, (Domain) semanticObject); 
				return; 
			case MinotorDslPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case MinotorDslPackage.EQUALS_BOOLEAN_EXPRESSION:
				sequence_EqualsBooleanExpression(context, (EqualsBooleanExpression) semanticObject); 
				return; 
			case MinotorDslPackage.EQUALS_EXPRESSION:
				sequence_EqualsExpression(context, (EqualsExpression) semanticObject); 
				return; 
			case MinotorDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case MinotorDslPackage.FENTITY:
				sequence_FEntity(context, (FEntity) semanticObject); 
				return; 
			case MinotorDslPackage.FRELATION:
				sequence_FRelation(context, (FRelation) semanticObject); 
				return; 
			case MinotorDslPackage.FRAGMENT_ATTRIBUTE:
				sequence_FragmentAttribute(context, (FragmentAttribute) semanticObject); 
				return; 
			case MinotorDslPackage.GREATER_THAN_EXPRESSION:
				sequence_GreaterThanExpression(context, (GreaterThanExpression) semanticObject); 
				return; 
			case MinotorDslPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case MinotorDslPackage.LESSER_THAN_EXPRESSION:
				sequence_LesserThanExpression(context, (LesserThanExpression) semanticObject); 
				return; 
			case MinotorDslPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case MinotorDslPackage.MATCH_MESSAGE:
				sequence_MatchMessage(context, (MatchMessage) semanticObject); 
				return; 
			case MinotorDslPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case MinotorDslPackage.NOT_LOGICAL_EXPRESSION:
				sequence_NotLogicalExpression(context, (NotLogicalExpression) semanticObject); 
				return; 
			case MinotorDslPackage.OBJECT:
				sequence_Object(context, (hu.bme.mit.dipterv.text.minotorDsl.Object) semanticObject); 
				return; 
			case MinotorDslPackage.OBJECT_TYPE:
				sequence_ObjectType(context, (ObjectType) semanticObject); 
				return; 
			case MinotorDslPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case MinotorDslPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case MinotorDslPackage.PAR:
				sequence_Par(context, (Par) semanticObject); 
				return; 
			case MinotorDslPackage.PAR_EXPRESSION:
				sequence_ParExpression(context, (ParExpression) semanticObject); 
				return; 
			case MinotorDslPackage.PARAMETER:
				sequence_Parameter(context, (hu.bme.mit.dipterv.text.minotorDsl.Parameter) semanticObject); 
				return; 
			case MinotorDslPackage.PARAMETER_CONSTRAINT:
				sequence_ParameterConstraint(context, (ParameterConstraint) semanticObject); 
				return; 
			case MinotorDslPackage.PARAMS:
				sequence_Params(context, (Params) semanticObject); 
				return; 
			case MinotorDslPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case MinotorDslPackage.RESET_CLOCK:
				sequence_ResetClock(context, (ResetClock) semanticObject); 
				return; 
			case MinotorDslPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case MinotorDslPackage.SCENARIO_CONTENT:
				sequence_ScenarioContent(context, (ScenarioContent) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Alt returns Alt
	 *
	 * Constraint:
	 *     expressions+=Expression+
	 */
	protected void sequence_Alt(ISerializationContext context, Alt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns AndExpression
	 *     BinaryLogicalExpression returns AndExpression
	 *     AndExpression returns AndExpression
	 *
	 * Constraint:
	 *     (lhs=LogicalExpression rhs=LogicalExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.AND_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.AND_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.AND_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.AND_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getLhsLogicalExpressionParserRuleCall_2_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRhsLogicalExpressionParserRuleCall_4_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AppearMessage returns AppearMessage
	 *
	 * Constraint:
	 *     (context=[ContextModel|ID] entity=[Entity|ID])
	 */
	protected void sequence_AppearMessage(ISerializationContext context, AppearMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.APPEAR_MESSAGE__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.APPEAR_MESSAGE__CONTEXT));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.APPEAR_MESSAGE__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.APPEAR_MESSAGE__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAppearMessageAccess().getContextContextModelIDTerminalRuleCall_2_0_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.APPEAR_MESSAGE__CONTEXT, false));
		feeder.accept(grammarAccess.getAppearMessageAccess().getEntityEntityIDTerminalRuleCall_2_2_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.APPEAR_MESSAGE__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionEntity returns AssertionEntity
	 *
	 * Constraint:
	 *     (context=[ContextModel|ID] entity=[Entity|ID] attribute=[Attribute|ID] operator+=Operator value+=AttributeValue)
	 */
	protected void sequence_AssertionEntity(ISerializationContext context, AssertionEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionRelation returns AssertionRelation
	 *
	 * Constraint:
	 *     (context=[ContextModel|ID] relation=[Relation|ID] attribute=[Attribute|ID] operator+=Operator value+=AttributeValue)
	 */
	protected void sequence_AssertionRelation(ISerializationContext context, AssertionRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValue returns AttributeValue
	 *
	 * Constraint:
	 *     (value=STRING | value=REAL | value=NUMBER | value='true' | value='false')
	 */
	protected void sequence_AttributeValue(ISerializationContext context, AttributeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         int?='int'? 
	 *         float?='float'? 
	 *         string?='string'? 
	 *         boolean?='boolean'? 
	 *         name=ID 
	 *         value=AttributeValue?
	 *     )
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChangeMessage returns ChangeMessage
	 *
	 * Constraint:
	 *     (disappear+=DisappearMessage | appear+=AppearMessage | changeto+=ChangeToMessage | changetor+=ChangeToRelation)
	 */
	protected void sequence_ChangeMessage(ISerializationContext context, ChangeMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChangeToMessage returns ChangeToMessage
	 *
	 * Constraint:
	 *     ((context=[ContextModel|ID] entity=[Entity|ID] attribute=[Attribute|ID])? changevalue=AttributeValue?)
	 */
	protected void sequence_ChangeToMessage(ISerializationContext context, ChangeToMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChangeToRelation returns ChangeToRelation
	 *
	 * Constraint:
	 *     ((context=[ContextModel|ID] relation=[Relation|ID] attribute=[Attribute|ID])? changevalue=AttributeValue?)
	 */
	protected void sequence_ChangeToRelation(ISerializationContext context, ChangeToRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClockConstraintExpression returns ClockConstraintExpression
	 *
	 * Constraint:
	 *     ((not?='not'? lclockconstraint=ClockConstraint) | (lclockconstraint=ClockConstraint rclockconstraint=ClockConstraint))
	 */
	protected void sequence_ClockConstraintExpression(ISerializationContext context, ClockConstraintExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClockConstraint returns ClockConstraint
	 *
	 * Constraint:
	 *     (clock=[Clock|ID] op=Operator constant=NUMBER)
	 */
	protected void sequence_ClockConstraint(ISerializationContext context, ClockConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.CLOCK_CONSTRAINT__CLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.CLOCK_CONSTRAINT__CLOCK));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.CLOCK_CONSTRAINT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.CLOCK_CONSTRAINT__OP));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.CLOCK_CONSTRAINT__CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.CLOCK_CONSTRAINT__CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClockConstraintAccess().getClockClockIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.CLOCK_CONSTRAINT__CLOCK, false));
		feeder.accept(grammarAccess.getClockConstraintAccess().getOpOperatorParserRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getClockConstraintAccess().getConstantNUMBERTerminalRuleCall_2_0(), semanticObject.getConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clock returns Clock
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Clock(ISerializationContext context, Clock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.CLOCK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.CLOCK__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClockAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstantParams returns ConstantParams
	 *
	 * Constraint:
	 *     ((values+=AttributeValue values+=AttributeValue+) | values+=AttributeValue+)?
	 */
	protected void sequence_ConstantParams(ISerializationContext context, ConstantParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=ID messages+=Message*)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextFragment returns ContextFragment
	 *
	 * Constraint:
	 *     (name=ID entities+=FEntity* relations+=FRelation*)
	 */
	protected void sequence_ContextFragment(ISerializationContext context, ContextFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextMessageContent returns ContextMessageContent
	 *
	 * Constraint:
	 *     (match+=MatchMessage | change+=ChangeMessage)
	 */
	protected void sequence_ContextMessageContent(ISerializationContext context, ContextMessageContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextMessage returns ContextMessage
	 *
	 * Constraint:
	 *     (content+=ContextMessageContent required?='required'? fail?='fail'? strict?='strict'?)
	 */
	protected void sequence_ContextMessage(ISerializationContext context, ContextMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextModel returns ContextModel
	 *
	 * Constraint:
	 *     (name=ID entities+=Entity* relations+=Relation*)
	 */
	protected void sequence_ContextModel(ISerializationContext context, ContextModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DisappearMessage returns DisappearMessage
	 *
	 * Constraint:
	 *     (context=[ContextModel|ID] entity=[Entity|ID])
	 */
	protected void sequence_DisappearMessage(ISerializationContext context, DisappearMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.DISAPPEAR_MESSAGE__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.DISAPPEAR_MESSAGE__CONTEXT));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.DISAPPEAR_MESSAGE__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.DISAPPEAR_MESSAGE__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisappearMessageAccess().getContextContextModelIDTerminalRuleCall_2_0_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.DISAPPEAR_MESSAGE__CONTEXT, false));
		feeder.accept(grammarAccess.getDisappearMessageAccess().getEntityEntityIDTerminalRuleCall_2_2_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.DISAPPEAR_MESSAGE__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns Domain
	 *
	 * Constraint:
	 *     (
	 *         specification='specification'? 
	 *         name=ID? 
	 *         includes+=Include* 
	 *         contextmodels+=ContextModel* 
	 *         contextfragments+=ContextFragment* 
	 *         objects+=Object* 
	 *         parameters+=Parameter* 
	 *         clocks+=Clock* 
	 *         constraints+=Constraint* 
	 *         scenarios+=Scenario*
	 *     )
	 */
	protected void sequence_Domain(ISerializationContext context, Domain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID attributes+=Attribute*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns EqualsBooleanExpression
	 *     BinaryLogicalExpression returns EqualsBooleanExpression
	 *     EqualsBooleanExpression returns EqualsBooleanExpression
	 *
	 * Constraint:
	 *     ((lhs=[Parameter|ID] rhs='true') | (lhs=[Parameter|ID] rhs='false'))
	 */
	protected void sequence_EqualsBooleanExpression(ISerializationContext context, EqualsBooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns EqualsExpression
	 *     BinaryLogicalExpression returns EqualsExpression
	 *     EqualsExpression returns EqualsExpression
	 *
	 * Constraint:
	 *     (lhs=[Parameter|ID] rhs=NUMBER)
	 */
	protected void sequence_EqualsExpression(ISerializationContext context, EqualsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.EQUALS_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.EQUALS_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.EQUALS_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.EQUALS_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getLhsParameterIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.EQUALS_EXPRESSION__LHS, false));
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getRhsNUMBERTerminalRuleCall_4_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (altCondition=LogicalExpression messages+=Message*)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FEntity returns FEntity
	 *
	 * Constraint:
	 *     (name=ID attributes+=FragmentAttribute*)
	 */
	protected void sequence_FEntity(ISerializationContext context, FEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FRelation returns FRelation
	 *
	 * Constraint:
	 *     (name=ID sender=[FEntity|ID] receiver=[FEntity|ID] attributes+=FragmentAttribute*)
	 */
	protected void sequence_FRelation(ISerializationContext context, FRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FragmentAttribute returns FragmentAttribute
	 *
	 * Constraint:
	 *     (
	 *         int?='int'? 
	 *         float?='float'? 
	 *         string?='string'? 
	 *         boolean?='boolean'? 
	 *         name=ID 
	 *         greater?='>'? 
	 *         smaller?='<'? 
	 *         greaterequals?='>='? 
	 *         smallerequals?='<='? 
	 *         equals?='=='? 
	 *         notequals?='!='? 
	 *         value=AttributeValue
	 *     )
	 */
	protected void sequence_FragmentAttribute(ISerializationContext context, FragmentAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns GreaterThanExpression
	 *     BinaryLogicalExpression returns GreaterThanExpression
	 *     GreaterThanExpression returns GreaterThanExpression
	 *
	 * Constraint:
	 *     (lhs=[Parameter|ID] rhs=NUMBER)
	 */
	protected void sequence_GreaterThanExpression(ISerializationContext context, GreaterThanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.GREATER_THAN_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.GREATER_THAN_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.GREATER_THAN_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.GREATER_THAN_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterThanExpressionAccess().getLhsParameterIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.GREATER_THAN_EXPRESSION__LHS, false));
		feeder.accept(grammarAccess.getGreaterThanExpressionAccess().getRhsNUMBERTerminalRuleCall_4_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Include returns Include
	 *
	 * Constraint:
	 *     (context=[ContextModel|ID] importURI=STRING)
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.INCLUDE__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.INCLUDE__CONTEXT));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.INCLUDE__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.INCLUDE__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getContextContextModelIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.INCLUDE__CONTEXT, false));
		feeder.accept(grammarAccess.getIncludeAccess().getImportURISTRINGTerminalRuleCall_3_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns LesserThanExpression
	 *     BinaryLogicalExpression returns LesserThanExpression
	 *     LesserThanExpression returns LesserThanExpression
	 *
	 * Constraint:
	 *     (lhs=[Parameter|ID] rhs=NUMBER)
	 */
	protected void sequence_LesserThanExpression(ISerializationContext context, LesserThanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.LESSER_THAN_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.LESSER_THAN_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.LESSER_THAN_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.LESSER_THAN_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLesserThanExpressionAccess().getLhsParameterIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.LESSER_THAN_EXPRESSION__LHS, false));
		feeder.accept(grammarAccess.getLesserThanExpressionAccess().getRhsNUMBERTerminalRuleCall_4_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (min=NUMBER max=NUMBER messages+=Message*)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatchMessage returns MatchMessage
	 *
	 * Constraint:
	 *     (context=[ContextModel|ID]? content=[ContextFragment|ID]?)
	 */
	protected void sequence_MatchMessage(ISerializationContext context, MatchMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (params+=Params | constantparams+=ConstantParams) 
	 *         required?='required'? 
	 *         fail?='fail'? 
	 *         strict?='strict'? 
	 *         sender=[Object|ID] 
	 *         receiver=[Object|ID] 
	 *         past?='pastConstraint'? 
	 *         future?='futureConstraint'? 
	 *         c=[Constraint|ID]? 
	 *         constraintexp=ClockConstraintExpression? 
	 *         resetinconstraint=ResetClock? 
	 *         clockconstraint?='clockConstraint'? 
	 *         cConstraint=ClockConstraintExpression? 
	 *         resetclock=ResetClock?
	 *     )
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns NotLogicalExpression
	 *     UnaryLogicalExpression returns NotLogicalExpression
	 *     NotLogicalExpression returns NotLogicalExpression
	 *
	 * Constraint:
	 *     operand=LogicalExpression
	 */
	protected void sequence_NotLogicalExpression(ISerializationContext context, NotLogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.NOT_LOGICAL_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.NOT_LOGICAL_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotLogicalExpressionAccess().getOperandLogicalExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ObjectType returns ObjectType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ObjectType(ISerializationContext context, ObjectType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.OBJECT_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.OBJECT_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (object+=ObjectType name=ID)
	 */
	protected void sequence_Object(ISerializationContext context, hu.bme.mit.dipterv.text.minotorDsl.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns Operator
	 *
	 * Constraint:
	 *     (
	 *         greater?='>' | 
	 *         smaller?='<' | 
	 *         greaterequals?='>=' | 
	 *         smallerequals?='<=' | 
	 *         equals?='==' | 
	 *         notequals?='!='
	 *     )
	 */
	protected void sequence_Operator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns OrExpression
	 *     BinaryLogicalExpression returns OrExpression
	 *     OrExpression returns OrExpression
	 *
	 * Constraint:
	 *     (lhs=LogicalExpression rhs=LogicalExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.OR_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.OR_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.OR_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.OR_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getLhsLogicalExpressionParserRuleCall_2_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRhsLogicalExpressionParserRuleCall_4_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParExpression returns ParExpression
	 *
	 * Constraint:
	 *     (name=ID messages+=Message*)
	 */
	protected void sequence_ParExpression(ISerializationContext context, ParExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Par returns Par
	 *
	 * Constraint:
	 *     parexpression+=ParExpression+
	 */
	protected void sequence_Par(ISerializationContext context, Par semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterConstraint returns ParameterConstraint
	 *
	 * Constraint:
	 *     (param=[Parameter|ID] operator+=Operator value+=AttributeValue object=[Object|ID])
	 */
	protected void sequence_ParameterConstraint(ISerializationContext context, ParameterConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (type=Type name=ID value=AttributeValue?)
	 */
	protected void sequence_Parameter(ISerializationContext context, hu.bme.mit.dipterv.text.minotorDsl.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Params returns Params
	 *
	 * Constraint:
	 *     ((params+=[Parameter|ID] params+=[Parameter|ID]+) | params+=[Parameter|ID]+)?
	 */
	protected void sequence_Params(ISerializationContext context, Params semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relation returns Relation
	 *
	 * Constraint:
	 *     (name=ID sender=[Entity|ID] receiver=[Entity|ID] attributes+=Attribute*)
	 */
	protected void sequence_Relation(ISerializationContext context, Relation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResetClock returns ResetClock
	 *
	 * Constraint:
	 *     clock=[Clock|ID]
	 */
	protected void sequence_ResetClock(ISerializationContext context, ResetClock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinotorDslPackage.Literals.RESET_CLOCK__CLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinotorDslPackage.Literals.RESET_CLOCK__CLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResetClockAccess().getClockClockIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MinotorDslPackage.Literals.RESET_CLOCK__CLOCK, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScenarioContent returns ScenarioContent
	 *
	 * Constraint:
	 *     (
	 *         alt+=Alt | 
	 *         message+=Message | 
	 *         par+=Par | 
	 *         loop+=Loop | 
	 *         contextmessage+=ContextMessage | 
	 *         paramConstraint+=ParameterConstraint | 
	 *         assertentity+=AssertionEntity | 
	 *         assertrelation+=AssertionRelation
	 *     )
	 */
	protected void sequence_ScenarioContent(ISerializationContext context, ScenarioContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     (name=ID scenariocontents+=ScenarioContent*)
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

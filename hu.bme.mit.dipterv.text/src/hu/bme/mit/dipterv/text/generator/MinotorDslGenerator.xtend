/*
 * generated by Xtext 2.24.0
 */
package hu.bme.mit.dipterv.text.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import com.google.inject.Inject
import hu.bme.mit.dipterv.text.minotorDsl.Domain
import hu.bme.mit.dipterv.text.minotorDsl.Message
import hu.bme.mit.dipterv.text.minotorDsl.LogicalExpression
import hu.bme.mit.dipterv.text.minotorDsl.AndExpression
import hu.bme.mit.dipterv.text.minotorDsl.EqualsExpression
import hu.bme.mit.dipterv.text.minotorDsl.LesserThanExpression
import hu.bme.mit.dipterv.text.minotorDsl.NotLogicalExpression
import hu.bme.mit.dipterv.text.minotorDsl.EqualsBooleanExpression
import hu.bme.mit.dipterv.text.minotorDsl.OrExpression
import hu.bme.mit.dipterv.text.minotorDsl.GreaterThanExpression
import hu.bme.mit.dipterv.text.minotorDsl.LooseMessage
import hu.bme.mit.dipterv.text.minotorDsl.StrictMessage
import hu.bme.mit.dipterv.text.minotorDsl.PastMessage
import hu.bme.mit.dipterv.text.minotorDsl.FutureMessage
import hu.bme.mit.dipterv.text.minotorDsl.StrictFutureMessage
import hu.bme.mit.dipterv.text.minotorDsl.RequiredLooseMessage
import hu.bme.mit.dipterv.text.minotorDsl.RequiredStrictMessage
import hu.bme.mit.dipterv.text.minotorDsl.RequiredPastMessage
import hu.bme.mit.dipterv.text.minotorDsl.RequiredFutureMessage
import hu.bme.mit.dipterv.text.minotorDsl.RequiredStrictFutureMessage
import hu.bme.mit.dipterv.text.minotorDsl.FailMessage
import hu.bme.mit.dipterv.text.minotorDsl.FailStrictMessage
import hu.bme.mit.dipterv.text.minotorDsl.FailPastMessage

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MinotorDslGenerator extends AbstractGenerator {
	@Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(s : resource.allContents.toIterable.filter(Domain)){
			fsa.generateFile("Specification.java", s.compile)
		}
	}
	
	def compile(Domain s) '''
		package generated;
	
		import java.io.FileNotFoundException;
		import java.io.PrintWriter;
		import java.io.UnsupportedEncodingException;
		import java.util.ArrayList;
		import java.util.HashMap;
		import java.util.Collections;
		import java.util.Comparator;
		import java.util.Arrays;
		import java.util.List;
		import java.util.Map;
		import java.util.Set;
		import java.util.TreeSet;
		
		import util.Automaton;
		import util.BasicTransition;
		import util.ClockConstraint;
		import util.UnwantedConstraint;
		import util.WantedConstraint;
		import util.State;
		import util.StateType;
		import util.Transition;
		import util.NeverClaimWriter;
		import util.OperatorFunctions;
		
		public class Specification{
			private String id = "«s.name»";
			private ArrayList<Automaton> automatas;
			
			public Specification(){
				automatas = new ArrayList<Automaton>();
				String str;
				String str1;
				String pre;
				String succ;
				State actualState;
				State acceptState;
				State finalState;
				State newState;
				State acceptState_new;
				OperatorFunctions opFunctions = new OperatorFunctions();
				«FOR scenario:s.scenarios»
					Automaton a = new Automaton("«scenario.name»");
					Automaton b;
					Map<String, Automaton> altauto;
					ArrayList<Automaton> parauto;
					Automaton loopauto;
					Automaton expression;
					int counter = 0;
					
					«FOR sc : scenario.scenariocontents»
						«FOR l :sc.loop»
							loopauto = new Automaton("loopauto" + counter);
							«FOR m : l.messages»
								«generateMessage(m)»
								loopauto.collapse(b);
							«ENDFOR»
							a.merge(opFunctions.loopSetup(loopauto, «l.min», «l.max»));
						«ENDFOR»
						«FOR p : sc.par»
							parauto = new ArrayList<Automaton>();
							«FOR pe : p.parexpression»
								expression = new Automaton("expauto" + counter);
								«FOR m : pe.messages»
									«generateMessage(m)»
									expression.collapse(b);
								«ENDFOR»
								parauto.add(expression);			
							«ENDFOR»
							a.merge(opFunctions.par(parauto));
						«ENDFOR»
						«FOR a : sc.alt»
						altauto = new HashMap<String, Automaton>();
							«FOR e : a.expressions»
								expression = new Automaton("expauto" + counter);
								«FOR m : e.messages»
									«generateMessage(m)»
									expression.collapse(b);
								«ENDFOR»
								altauto.put("«compile_alt_condition(e.altCondition)»", expression);
							«ENDFOR»
							a.merge(altauto);
						«ENDFOR»
						«FOR m : sc.message»
							«generateMessage(m)»
							a.collapse(b);
						«ENDFOR»
					«ENDFOR»
					a.rename();
					automatas.add(a);
				«ENDFOR»
			}
			
			public void listAutomatas(){
				for(Automaton a : this.automatas){
					for(State s : a.getStates()){
						s.writeState();	
					}
					//TODO: print out transitions
					/*
					for(Transition t : a.getTransitions()){
						t.writeTransition();
					}*/
				}
			}

			public List<Automaton> getAutomata() {
				return automatas;
			}

			public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException {
				Specification specification = new Specification();
				specification.listAutomatas();
				
				//TODO: refactor never claim and uppaal printers
				/*NeverClaimWriter ncWriter = new NeverClaimWriter();
				ncWriter.writeNeverClaim("«s.name»", specification.automatas);
				
				«new UppaalWriter().compile_uppaal_writer(s)»*/
			}
		}
	'''
	
	def compile_message(Message m)
	'''«m.generateMessage»'''
	
	def dispatch generateMessage(LooseMessage m)
	'''«new ClockRegularMessage().compile_msg_clock(m)»'''
	
	def dispatch generateMessage(StrictMessage m)
	'''«new ClockRegularMessage().compile_strict_clock(m)»'''
	
	def dispatch generateMessage(PastMessage m)
	'''«new ClockRegularMessage().compile_past_clock(m)»'''
	
	def dispatch generateMessage(FutureMessage m)
	'''«IF m.constraintexp === null 
		&& m.resetinconstraint === null 
		&& m.message.get(0).CConstraint === null 
		&& m.message.get(0).resetclock === null»
		«new RegularMessage().compile_future(m)»
	   «ELSE»«new ClockRegularMessage().compile_future_clock(m)»«ENDIF»
	'''
	
	def dispatch generateMessage(StrictFutureMessage m)
	'''«IF m.futureMessage.get(0).constraintexp === null 
		&& m.futureMessage.get(0).resetinconstraint === null 
		&& m.futureMessage.get(0).message.get(0).CConstraint === null 
		&& m.futureMessage.get(0).message.get(0).resetclock === null»
		«new RegularMessage().compile_strict_future(m)»
		«ELSE»«new ClockRegularMessage().compile_future_strict_clock(m)»«ENDIF»
	'''
	
	def dispatch generateMessage(RequiredLooseMessage m)
	'''«IF m.message.get(0).CConstraint === null 
		&& m.message.get(0).resetclock === null»
		«new RequiredMessage().compile_required(m)»
		«ELSE»«new ClockRequiredMessage().compile_required_clock(m)»«ENDIF»
	'''
	
	def dispatch generateMessage(RequiredStrictMessage m)
	'''«IF m.strictMessage.get(0).message.get(0).CConstraint === null 
		&& m.strictMessage.get(0).message.get(0).resetclock === null»
		«new RequiredMessage().compile_strict_required(m)»
		«ELSE»«new ClockRequiredMessage().compile_strict_required_clock(m)»«ENDIF»
	'''
	
	def dispatch generateMessage(RequiredPastMessage m)
	'''«IF m.pastMessage.get(0).constraintexp === null 
		&& m.pastMessage.get(0).resetinconstraint === null 
		&& m.pastMessage.get(0).message.get(0).CConstraint === null 
		&& m.pastMessage.get(0).message.get(0).resetclock === null»
		«new RequiredMessage().compile_required_past(m)»
		«ELSE»«new ClockRequiredMessage().compile_required_past_clock(m)»«ENDIF»
	'''
	
	def dispatch generateMessage(RequiredFutureMessage m)
	'''«IF m.futureMessage.get(0).constraintexp === null 
		&& m.futureMessage.get(0).resetinconstraint === null 
		&& m.futureMessage.get(0).message.get(0).CConstraint === null 
		&& m.futureMessage.get(0).message.get(0).resetclock === null»
		«new RequiredMessage().compile_required_future(m)»
		«ELSE»«new ClockRequiredMessage().compile_required_future_clock(m)»«ENDIF»
	'''
	
	def dispatch generateMessage(RequiredStrictFutureMessage m)
	'''«IF m.strictFutureMessage.get(0).futureMessage.get(0).constraintexp === null 
		&& m.strictFutureMessage.get(0).futureMessage.get(0).resetinconstraint === null 
		&& m.strictFutureMessage.get(0).futureMessage.get(0).message.get(0).CConstraint === null 
		&& m.strictFutureMessage.get(0).futureMessage.get(0).message.get(0).resetclock === null»
		«new RequiredMessage().compile_strict_required_future(m)»
		«ELSE»«new ClockRequiredMessage().compile_strict_required_future_clock(m)»«ENDIF»
	'''
	
	def dispatch generateMessage(FailMessage m)
	'''«new hu.bme.mit.dipterv.text.generator.FailMessage().compile_fail(m)»'''
	
	def dispatch generateMessage(FailStrictMessage m)
	'''«new hu.bme.mit.dipterv.text.generator.FailMessage().compile_strict_fail(m)»'''
	
	def dispatch generateMessage(FailPastMessage m)
	'''«new hu.bme.mit.dipterv.text.generator.FailMessage().compile_fail_past(m)»'''
	
	def compile_alt_condition(LogicalExpression a)
	'''«a.generateLogicalExpression»'''

	def dispatch generateLogicalExpression(AndExpression expression)
	'''(«expression.lhs») && («expression.rhs»)'''
	
	def dispatch generateLogicalExpression(OrExpression expression)
	'''(«expression.lhs») || («expression.rhs»)'''
	
	def dispatch generateLogicalExpression(EqualsExpression expression) 
	'''«expression.lhs.name» == «expression.rhs»'''
	
	def dispatch generateLogicalExpression(EqualsBooleanExpression expression) 
	'''«expression.lhs.name» == «expression.rhs»'''
	
	def dispatch generateLogicalExpression(GreaterThanExpression expression)
	'''«expression.lhs.name» > «expression.rhs»'''
	
	def dispatch generateLogicalExpression(LesserThanExpression expression)
	'''«expression.lhs.name» < «expression.rhs»'''
	
	def dispatch generateLogicalExpression(NotLogicalExpression expression)
	'''!(«expression.operand»)'''
}